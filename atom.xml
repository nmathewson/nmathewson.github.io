<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>inter allia</title>
	<subtitle>adventures among the onions</subtitle>
	<link href="https://www.inter-allia.net/atom.xml" rel="self" type="application/atom+xml"/>
	<link href="https://www.inter-allia.net"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2021-04-27T00:00:00+00:00</updated>
	<id>https://www.inter-allia.net/atom.xml</id>
	<entry xml:lang="en">
		<title>Implementing Rust futures when you only have async functions</title>
		<published>2021-04-27T00:00:00+00:00</published>
		<updated>2021-04-27T00:00:00+00:00</updated>
		<link href="https://www.inter-allia.net/async-into-future/" type="text/html"/>
		<id>https://www.inter-allia.net/async-into-future/</id>
		<content type="html">&lt;p&gt;Because doesn&#x27;t yet support
&lt;a href=&quot;https:&#x2F;&#x2F;smallcultfollowing.com&#x2F;babysteps&#x2F;blog&#x2F;2019&#x2F;10&#x2F;26&#x2F;async-fn-in-traits-are-hard&#x2F;&quot;&gt;asynchronous functions in traits&lt;&#x2F;a&gt;,
several important traits (like
&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.14&#x2F;futures&#x2F;io&#x2F;trait.AsyncRead.html&quot;&gt;&lt;code&gt;AsyncRead&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;
and &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.14&#x2F;futures&#x2F;stream&#x2F;trait.Stream.html&quot;&gt;&lt;code&gt;Stream&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; )
define their interface using functions that return
&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;task&#x2F;enum.Poll.html&quot;&gt;&lt;code&gt;Poll&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.  So, what can
you do when you have a function that &lt;em&gt;is&lt;&#x2F;em&gt; async, and you need to use it to
implement one of these traits?&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;(I&#x27;ll be assuming that you already know a little about pinning,
pin-projection, futures, and async programming in Rust: not because they&#x27;re
easy topics, but because I&#x27;m still learning them myself, and I don&#x27;t
understand them well enough be a good teacher.)&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-little-background&quot;&gt;A little background&lt;&#x2F;h1&gt;
&lt;p&gt;Here&#x27;s a situation I ran into earlier this year.  In the end, I only
solved it with help from
&lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;dfranke&#x2F;status&#x2F;1368974517289246724&quot;&gt;Daniel Franke&lt;&#x2F;a&gt;,
so I decided that I should write up the solution here in case it can help
somebody else.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve been working on &lt;a href=&quot;https:&#x2F;&#x2F;gitlab.torproject.org&#x2F;tpo&#x2F;core&#x2F;arti&#x2F;&quot;&gt;Arti&lt;&#x2F;a&gt;, an
implementation of the
&lt;a href=&quot;https:&#x2F;&#x2F;gitlab.torproject.org&#x2F;tpo&#x2F;core&#x2F;torspec&#x2F;&quot;&gt;Tor protocols&lt;&#x2F;a&gt; in Rust.
After a bunch of hacking, I finally got to the point where I had a &lt;code&gt;DataStream&lt;&#x2F;code&gt;
type that provides an anonymous connection over the Tor network:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DataStream {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]) -&amp;gt; io::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;
    { ... }
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]) -&amp;gt; io::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;
    { ... }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, there&#x27;s a lot of complexity hiding in those ellipses.  A Tor
implementation that&#x27;s trying to read may need to wait for data to arrive.  It
may also need to &lt;em&gt;send&lt;&#x2F;em&gt; messages in response to arriving data, update
internal state, and all kinds of delightful stuff.  So rewriting those
functions as explicitly returning a typed future was &lt;em&gt;not&lt;&#x2F;em&gt; an option.&lt;&#x2F;p&gt;
&lt;p&gt;But I wanted &lt;code&gt;DataStream&lt;&#x2F;code&gt; to implement &lt;code&gt;AsyncRead&lt;&#x2F;code&gt; and &lt;code&gt;AsyncWrite&lt;&#x2F;code&gt;, so it
can be used with other code in the Rust async ecosystem.  That way,
integrating other Rust programs with Arti will be as simple as teaching them
to construct a &lt;code&gt;DataStream&lt;&#x2F;code&gt; in place of a &lt;code&gt;TcpStream&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at &lt;code&gt;AsyncRead&lt;&#x2F;code&gt;: it&#x27;s simpler than &lt;code&gt;AsyncWrite&lt;&#x2F;code&gt;.  The only required
method in &lt;code&gt;AsyncRead&lt;&#x2F;code&gt; is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;poll_read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Pin&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut Self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Context&amp;lt;&amp;#39;_&amp;gt;,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
) -&amp;gt; Poll&amp;lt;io::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;read&lt;&#x2F;code&gt; has to check whether there&#x27;s any data that can be read into &lt;code&gt;buf&lt;&#x2F;code&gt;
immediately, without blocking.  If there is, we read the data and
return the number of bytes read.  Otherwise, we have to schedule ourself on
&lt;code&gt;cx&lt;&#x2F;code&gt;, and return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#other-read-results&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Compare &lt;code&gt;poll_read&lt;&#x2F;code&gt; to the &lt;code&gt;read&lt;&#x2F;code&gt; function in &lt;code&gt;DataStream&lt;&#x2F;code&gt;.  First off,
there&#x27;s a mismatch between how these two functions use their output buffers.
Because &lt;code&gt;DataStream::read&lt;&#x2F;code&gt; is async, it returns a future that will hang on to
its buffer until the future is finally ready.  But &lt;code&gt;poll_read&lt;&#x2F;code&gt; has to returns
right away, and it can&#x27;t hang on to its buffer at all.  So I started by
defining a wrapper variant of &lt;code&gt;DataStream&lt;&#x2F;code&gt; to implements the behavior that
&lt;code&gt;poll_read&lt;&#x2F;code&gt; would need:&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#inefficient&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DataReaderImpl {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: DataStream,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pending&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;
    offset: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DataReaderImpl {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: DataStream,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pending&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;
}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DataReaderImpl {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: DataStream) -&amp;gt; DataReaderImpl {
        DataReaderImpl {
            s,
            pending: Vec::new(),
        }
    }
    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fill_buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) -&amp;gt; io::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt; {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; data = vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; len = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.s.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; data[..]).await?;
        data.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;truncate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(len);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.pending.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;extend&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(data);
        Ok(len)
    }
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;extract_bytes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; n = cmp::min(buf.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.pending.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;());
        buf[..n].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;copy_from_slice&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.pending[..n]);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.pending.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;drain&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;..n);
        n
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then, I thought, it ought to be easy to write &lt;code&gt;AsyncRead&lt;&#x2F;code&gt;!  Here was my first
try:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; This won&amp;#39;t work...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;AsyncRead &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DataReaderImpl {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;poll_read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Pin&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut Self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;,
                 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Context&amp;lt;&amp;#39;_&amp;gt;,
                 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]) -&amp;gt; Poll&amp;lt;io::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;&amp;gt; {
       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.pending.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_empty&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; looks like we need more bytes.
            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; fut = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fill_buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
            futures::pin_mut!(fut);
            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; fut.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;poll&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(cx) {
                Poll::Ready(Err(e)) =&amp;gt;
                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Poll::Ready(Err(e)),
                Poll::Ready(Ok(n)) =&amp;gt;
                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; n == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Poll::Ready(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; EOF
                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
                Poll::Pending =&amp;gt;
                    todo!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;crud, where do i put the future?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;),
            }
        }

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We have some data; move it out to the caller.
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; n = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;extract_bytes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(buf);
        Poll::Ready(Ok(n))
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far, so good!  But do I do if the future says it&#x27;s pending?  I need to
store it and poll it again later the next time I call this function.  But to
do that, I won&#x27;t be able to pin it to the stack!  I&#x27;ll have to store it in
the structure instead.  And since it comes from an async function, it won&#x27;t
have a type that I can name; I&#x27;ll have to store it as a &lt;code&gt;Box&amp;lt;dyn Future&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Oh hang on, it&#x27;ll need to be pinned. And sometimes I won&#x27;t have a future at
all.  Maybe I store it in an &lt;code&gt;Option&amp;lt;Pin&amp;lt;Box&amp;lt;dyn Future&amp;gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;(This is the point where I had to take a break and figure out
&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pin-project&#x2F;1.0.7&#x2F;pin_project&#x2F;index.html&quot;&gt;pin-projection&lt;&#x2F;a&gt;.)&lt;&#x2F;p&gt;
&lt;p&gt;But after I played around with &lt;em&gt;that&lt;&#x2F;em&gt; for a while, I hit the final snag:
ultimately, I was trying to create a
&lt;a href=&quot;https:&#x2F;&#x2F;boats.gitlab.io&#x2F;blog&#x2F;post&#x2F;2018-01-25-async-i-self-referential-structs&#x2F;#self-referential-structs&quot;&gt;self-referential structure&lt;&#x2F;a&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#self-ref&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;,
which you can&#x27;t do in safe Rust.
You see, the future returned by &lt;code&gt;DataReaderImpl::fill_buf&lt;&#x2F;code&gt; needs to hold a
reference to the &lt;code&gt;DataReaderImpl&lt;&#x2F;code&gt;, and so the future needs to &lt;em&gt;outlive&lt;&#x2F;em&gt; the
DataReaderImpl.  That means you can&#x27;t store it in the DataReaderImpl.  You
can&#x27;t even store it and the DataReaderImpl in the same struct: that creates
self-reference.&lt;&#x2F;p&gt;
&lt;p&gt;So what could I do?  Was I supposed to use unsafe code or some tricky
crate to make a self-referential struct anyway?  Was my solution
fundamentally flawed?  Was I even trying to do something possible‽&lt;&#x2F;p&gt;
&lt;p&gt;I asked for help on Twitter.  Fortunately, Daniel Franke got back to me and
walked me through the actual answer.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;hold-the-future-or-the-reader-not-both&quot;&gt;Hold the future or the reader: not both!&lt;&#x2F;h1&gt;
&lt;p&gt;Here&#x27;s the trick: We define an enum that holds the &lt;code&gt;DataReaderImpl&lt;&#x2F;code&gt; &lt;em&gt;or&lt;&#x2F;em&gt; the
future that its &lt;code&gt;fill_buf&lt;&#x2F;code&gt; function returns, but not both at once.  That way,
we never have a self-referential structure!&lt;&#x2F;p&gt;
&lt;p&gt;First we had to define a new variation on &lt;code&gt;fill_buf&lt;&#x2F;code&gt; that will take
ownership of the reader, and pass it back once it&#x27;s done:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DataReaderImpl {
    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;owning_fill_buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) -&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, io::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;) {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; r = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;fill_buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().await;
        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, r)
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then we had to define an enum that could hold either the future or the
&lt;code&gt;DataReaderImpl&lt;&#x2F;code&gt; object, along with a wrapper struct to hold the enum.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;OwnedResult = (DataReaderImpl, io::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;State {
    Closed,
    Ready(DataReaderImpl),
    Reading(Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output=OwnedResult&amp;gt;&amp;gt;&amp;gt;),
}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DataReader {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;state&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;State&amp;gt;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that the &lt;code&gt;DataReader&lt;&#x2F;code&gt; struct holds an &lt;code&gt;Option&amp;lt;State&amp;gt;&lt;&#x2F;code&gt;—we&#x27;ll want
to modify the state object destructively, so we&#x27;ll need to take ownership of
it in &lt;code&gt;poll_read&lt;&#x2F;code&gt; and then replace it with something else.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#memswap&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;With this groundwork in place we can finally give an implementation
of &lt;code&gt;AsyncRead&lt;&#x2F;code&gt; that works:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;AsyncRead &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DataReader {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;poll_read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Pin&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut Self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;,
                 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Context&amp;lt;&amp;#39;_&amp;gt;,
                 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]) -&amp;gt; Poll&amp;lt;io::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;&amp;gt; {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We&amp;#39;re taking this temporarily. We have to put
        &#x2F;&#x2F; something back before we return.
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.state.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We own the state, so we can destructure it.
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; future = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state {
            State::Closed =&amp;gt; {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.state = Some(State::Closed);
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Poll::Ready(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));
            }
            State::Ready(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; imp) =&amp;gt; {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; n = imp.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;extract_bytes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(buf);
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; n &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.state = Some(State::Ready(imp));
                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We have data, so we can give it back now.
                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Poll::Ready(Ok(n));
                }
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Nothing available; launch a read and poll it.
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Box::pin(imp.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;owning_fill_buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;())
            }
            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; If we have a future, we need to poll it.
            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;State::Reading(fut) =&amp;gt; fut,
        };

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Now we have a future for an in-progress read.
        &#x2F;&#x2F; Can it make any progress?
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; future.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;poll&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(cx) {
            Poll::Ready((_imp, Err(e))) =&amp;gt; { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Error
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.state = Some(State::Closed);
                Poll::Ready(Err(e))
            }
            Poll::Ready((_imp, Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;))) =&amp;gt; { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; EOF
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.state = Some(State::Closed);
                Poll::Ready(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;))
            }
            Poll::Ready((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; imp, Ok(_))) =&amp;gt; {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We have some data!
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; n = imp.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;extract_bytes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(buf);
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.state = Some(State::Ready(imp));
                debug_assert!(n &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
                Poll::Ready(Ok(n))
            }
            Poll::Pending =&amp;gt; {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; We&amp;#39;re pending; remember the future
                &#x2F;&#x2F; and tell the caller.
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.state = Some(State::Reading(future));
                Poll::Pending
            }
        }
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now when &lt;code&gt;poll_read()&lt;&#x2F;code&gt; takes ownership of the previous state,
it either owns a &lt;code&gt;DataReaderImpl&lt;&#x2F;code&gt; or a future returned by
&lt;code&gt;owning_fill_buf()&lt;&#x2F;code&gt;—but never both at once, so we don&#x27;t have any
self-reference problems.  When it&#x27;s done, it has to put a new valid state
back before it returns.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusions&quot;&gt;Conclusions&lt;&#x2F;h1&gt;
&lt;p&gt;For the current version of all this code, have a look at
&lt;a href=&quot;https:&#x2F;&#x2F;gitlab.torproject.org&#x2F;tpo&#x2F;core&#x2F;arti&#x2F;-&#x2F;blob&#x2F;main&#x2F;tor-proto&#x2F;src&#x2F;stream&#x2F;data.rs&quot;&gt;&lt;code&gt;tor_proto::stream::data&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;
in Arti.  Note that the Arti code is more complex than what I have in this
post, and some of that complexity is probably unnecessary: I&#x27;ve been learning
as I go.&lt;&#x2F;p&gt;
&lt;p&gt;I hope that someday there&#x27;s an easier way to do all of this (real
asynchronous traits, maybe?) but in the meantime, I hope that this write-up
will be useful to somebody else.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;other-read-results&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;We might also have to report an EOF as &lt;code&gt;Poll::Ready(Ok(0))&lt;&#x2F;code&gt;, or an
error as &lt;code&gt;Poll::Ready(Err(_)&lt;&#x2F;code&gt;.  But let&#x27;s keep this simple.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;inefficient&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;At this point I started writing my code really inefficiently, since
I was just trying to get it to work.  In the interest of clarity,
I&#x27;ll leave it as inefficient code here too.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;self-ref&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;Self-referential structures in Rust require &lt;code&gt;unsafe&lt;&#x2F;code&gt; code and pinning.
I spent a semi-unpleasant hour or two looking through example
code here just to see what would be involved, and tried learning
the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;rental&#x2F;0.5.4&#x2F;rental&#x2F;&quot;&gt;rental&lt;&#x2F;a&gt; crate, in case
it would help.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;memswap&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;We could probably use &lt;code&gt;std::mem::replace&lt;&#x2F;code&gt; for this too, but I don&#x27;t
expect there would be a performance difference.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Contacting me</title>
		<published>2021-04-26T00:00:00+00:00</published>
		<updated>2021-04-26T00:00:00+00:00</updated>
		<link href="https://www.inter-allia.net/contact/" type="text/html"/>
		<id>https://www.inter-allia.net/contact/</id>
		<content type="html">&lt;p&gt;For work:  email me at &lt;code&gt;nickm atsign torproject dot org&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Not for work: email me at &lt;code&gt;nickm atsign alum dot mit dot edu&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;(If you use gpg, it will take me a few extra days to get around to your
email.)&lt;&#x2F;p&gt;
&lt;p&gt;Send ALL press inquiries to &lt;code&gt;press at torproject dot org&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;You can find me as &lt;code&gt;nickm&lt;&#x2F;code&gt; on IRC at OFTC.net.&lt;&#x2F;p&gt;
&lt;p&gt;If you want to get to me in public, I&#x27;m on twitter as
&lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nickm_tor&quot;&gt;&lt;code&gt;nickm_tor&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;You can find my older website at &lt;a href=&quot;http:&#x2F;&#x2F;www.wangafu.net&#x2F;%7Enickm&#x2F;&quot;&gt;wangafu.net&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;—nickm&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Lorax Ipsum</title>
		<published>2021-04-26T00:00:00+00:00</published>
		<updated>2021-04-26T00:00:00+00:00</updated>
		<link href="https://www.inter-allia.net/lorax-ipsum/" type="text/html"/>
		<id>https://www.inter-allia.net/lorax-ipsum/</id>
		<content type="html">&lt;p&gt;Lorax ipsum gruvvulus thneed amet, snergelly once-ler lerkim, sed do
barbaloot tempor gluppitus ut labore et truffula magna aliqua.  Ut
enim ad grickle-grass veniam, quis miff-muffered ga-zumpco laboris
nisi ut cruffulus ex ea schloppity consequat. &lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt; Duis aute
snarggle in swomeeswans in voluptate axe-hacker esse rippulus crummii
eu moof nulla snuvv.&lt;&#x2F;p&gt;
&lt;p&gt;Barbaloot tempor gluppitus ut labore et truffula magna aliqua.  Ut
enim ad grickle-grass veniam, quis miff-muffered ga-zumpco laboris
nisi ut cruffulus ex ea schloppity consequat.  Duis aute snarggle in
swomeeswans in voluptate axe-hacker esse rippulus crummii eu moof
nulla snuvv.
Lorax ipsum gruvvulus thneed amet, snergelly once-ler lerkim, sed do
barbaloot tempor gluppitus ut labore et truffula magna aliqua.  Ut
enim ad grickle-grass veniam, quis miff-muffered ga-zumpco laboris
nisi ut cruffulus ex ea schloppity consequat.  Duis aute snarggle in
swomeeswans in voluptate axe-hacker esse rippulus crummii eu moof
nulla snuvv.&lt;&#x2F;p&gt;
&lt;p&gt;Ad grickle-grass veniam, quis miff-muffered ga-zumpco laboris
nisi ut cruffulus ex ea schloppity consequat.  Duis aute snarggle in
swomeeswans in voluptate axe-hacker esse rippulus crummii eu moof
nulla snuvv.
Lorax ipsum gruvvulus thneed amet, snergelly once-ler lerkim, sed do
barbaloot tempor gluppitus ut labore et truffula magna aliqua.  Ut
enim ad grickle-grass veniam, quis miff-muffered ga-zumpco laboris
nisi ut cruffulus ex ea schloppity consequat.  Duis aute snarggle in
swomeeswans in voluptate axe-hacker esse rippulus crummii eu moof
nulla snuvv.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;By the way, be careful when you tweet the
&amp;quot;&lt;a href=&quot;https:&#x2F;&#x2F;loremipsum.io&#x2F;&quot;&gt;&lt;em&gt;lorem ipsum&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;&amp;quot; text or anything like it.  I
did so once, and immediately got followed by dozens of maddened
spambots.&lt;&#x2F;p&gt;
&lt;p&gt;My working theory is:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Somebody is selling a spambot that the user needs
to configure with a list of search terms.&lt;&#x2F;li&gt;
&lt;li&gt;The default list of search terms includes some or all of the &lt;em&gt;lorem
ipsum&lt;&#x2F;em&gt; text.&lt;&#x2F;li&gt;
&lt;li&gt;At least some users never actually change the configuration.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This was a few years back, so maybe those bots are gone now.  Why not
tweet some &lt;em&gt;lorem ipsum&lt;&#x2F;em&gt; and find out?&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
